### 哈密顿回路问题
#### 问题描述

- 爱尔兰数学家哈密顿提出了著名的周游世界的问题。设正面体20个顶点代表20个城市，哈密顿回路问题要求从一个城市出发，经过每一个城市恰好一次，然后回到该城市。

- 输入：一个含ｎ个结点的无向图(n个城市)
- 输出：路过城市的路径

- 解题步骤跟图着色差不多，关键点在于如何判断城市是否满足要求，这里不同。

#### 想法

- 回溯法求解哈密顿问题，首先把所有顶点的访问标志初始化为0，然后在解空间树中从根结点开始搜索，如果从根结点到当前结点对应一部分解，即满足上述约束条件，则在当前结点处选择第一颗子树继续搜索，否则，对当前子树的兄弟结点进行搜索，如果当前结点的所有子树都已尝试过并且发生冲突，则回溯到当前结点的父结点。

#### 样例输入的城市结点图图

![城市分布图](../../images/hamilton.png)

#### 图的存储(邻接矩阵)

![邻接矩阵](../../images/hamilton_city.png)

#### 解题过程

1. 用一个数组track[]存放经过的城市结点信息
2. 初始化track[]{0,0,0,0,0}
3. 用一个索引index表示待考察城市的下标
4. 默认从第一个城市开始,track[0]=1,待考察下标就是index=1
5. 判断待考察城市是否冲突
  - 判断该城市track[index]是否已经走过
  - 判断该城市与前一个城市track[index-1]之间是否有边
  - 若是最后一个城市，则判断与第一个城市是否有边
6. 若5中有冲突,则继续考察下一个城市track[index] = track[index]+1;
7. 若所有城市都考察完还是冲突，则回溯到前一个城市index = index-1;

#### 搜索解空间

![哈密顿回路搜索空间](../../images/HSP_tree.png)

#### 经过城市结果

- **track:{1,2,3,5,4}**

#### 详细代码移步

- [哈密顿回路](https://github.com/Mr-Joke/Algorithm/blob/master/BackTrack/src/Hamilton.java)
